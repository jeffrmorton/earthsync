name: Build and Test EarthSync

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: earthsync
        continue-on-error: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
        continue-on-error: false

      - name: Install Docker Compose V2
        run: |
          DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
          mkdir -p $DOCKER_CONFIG/cli-plugins
          curl -SL https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
          chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
          docker compose version
        continue-on-error: false

      - name: Verify docker-compose.yml exists
        working-directory: ./earthsync
        run: |
          ls -l docker-compose.yml
          echo "Verifying docker-compose.yml content (healthcheck example)..."
          grep -A 5 "healthcheck:" docker-compose.yml || echo "Healthcheck section not found or malformed (may be OK)"

      - name: Build and Run Services with Docker Compose
        working-directory: ./earthsync
        run: docker compose up -d --build --remove-orphans
        continue-on-error: false

      - name: Wait for Services to be Healthy
        working-directory: ./earthsync
        run: |
          echo "Waiting for services to stabilize and become healthy..."
          sleep 15
          echo "Checking service health status..."
          MAX_RETRIES=30
          RETRY_INTERVAL=3
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking server health..."
            # Check main services
            SERVER_HEALTH=$(curl -fsS --max-time 2 http://localhost:3000/health)
            CLIENT_HEALTH=$(curl -fsS --max-time 2 http://localhost:3001 || echo "Client check failed") # Allow client check failure briefly
            if [[ "$SERVER_HEALTH" == *"OK"* ]]; then
              echo "Server is healthy!"
              # Add a brief pause after server is healthy, before declaring success
              sleep 5
              break
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Server failed to become healthy within timeout."
              echo "--- Server Health Response ---"
              echo "$SERVER_HEALTH"
              echo "--- Server Logs ---"
              docker compose logs server || echo "Failed to get server logs."
              echo "--- Detector1 Logs ---"
              docker compose logs detector1 || echo "Failed to get detector1 logs."
              exit 1
            fi
            sleep $RETRY_INTERVAL
          done
        continue-on-error: false

      - name: Set up Node.js for Testing
        uses: actions/setup-node@v4
        with:
          node-version: '18'
        continue-on-error: false

      - name: Install Test Dependencies
        working-directory: ./earthsync
        run: npm install --save-dev axios ws ioredis bcryptjs jsonwebtoken jest@^29 crypto-js
        continue-on-error: false

      - name: Run Integration Tests
        working-directory: ./earthsync
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: password
          API_BASE_URL: http://localhost:3000
          WS_URL: ws://localhost:3000
          JWT_SECRET: 1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p
          API_INGEST_KEY: changeme-in-production # Match server .env for testing
          NODE_ENV: test
          JEST_TIMEOUT: 30000 # Keep timeout, but added delays in test
        run: |
          cat << 'TEST_EOF' > integration.test.js
          const axios = require('axios');
          const WebSocket = require('ws');
          const Redis = require('ioredis');
          const jwt = require('jsonwebtoken');
          const CryptoJS = require('crypto-js');

          const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
          const WS_URL = process.env.WS_URL || 'ws://localhost:3000';
          const JWT_SECRET = process.env.JWT_SECRET || '1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p';
          const API_INGEST_KEY = process.env.API_INGEST_KEY || 'changeme-in-production';
          const TEST_TIMEOUT = parseInt(process.env.JEST_TIMEOUT || '30000', 10);
          const DOWNSAMPLE_FACTOR = 5;
          const RAW_FREQUENCY_POINTS = 5501;
          const EXPECTED_DOWNSAMPLED_LENGTH = Math.ceil(RAW_FREQUENCY_POINTS / DOWNSAMPLE_FACTOR);

          const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

          // Main Redis client (for user keys)
          const redis = new Redis({
              host: process.env.REDIS_HOST || 'localhost',
              port: parseInt(process.env.REDIS_PORT || '6379', 10),
              password: process.env.REDIS_PASSWORD || 'password',
              lazyConnect: true,
              keyPrefix: 'userkey:',
              retryStrategy: times => Math.min(times * 100, 3000),
              reconnectOnError: () => true,
              maxRetriesPerRequest: 3,
              showFriendlyErrorStack: process.env.NODE_ENV !== 'production'
          });

           // Separate client for stream/history/peaks (no prefix)
          const streamRedis = new Redis({
               host: process.env.REDIS_HOST || 'localhost',
               port: parseInt(process.env.REDIS_PORT || '6379', 10),
               password: process.env.REDIS_PASSWORD || 'password',
               lazyConnect: true,
               retryStrategy: times => Math.min(times * 100, 3000),
               reconnectOnError: () => true,
               maxRetriesPerRequest: 3
           });


          describe('EarthSync Integration Tests (v1.1.8)', () => {
              let authToken;
              let encryptionKey;
              const testDetectorIdBase = 'ci_detector';

              jest.setTimeout(TEST_TIMEOUT);

              beforeAll(async () => {
                  try {
                      await redis.connect();
                      await streamRedis.connect();
                      await redis.ping();
                      await streamRedis.ping();
                      console.log('Redis connections successful for tests.');
                      // Clean up potential leftover test data
                      const userKey = await redis.keys(`ci_testuser`);
                      if (userKey.length > 0) await redis.del(userKey);
                      const dataKeys = await streamRedis.keys(`*${testDetectorIdBase}*`);
                      if (dataKeys.length > 0) await streamRedis.del(dataKeys);
                      const streamKey = await streamRedis.keys('spectrogram_stream');
                      if (streamKey.length > 0) await streamRedis.del(streamKey); // Clear stream too
                       console.log('Cleaned up potential leftover test data.');
                  } catch (err) {
                      console.error('Redis connection or cleanup failed:', err);
                      throw new Error('Cannot connect to Redis or clean up, aborting tests.');
                  }
                  try {
                      console.log('Attempting to register test user...');
                      await axios.post(`${API_BASE_URL}/register`, { username: 'ci_testuser', password: 'ci_password123' });
                      console.log('Test user registered.');
                  } catch (err) {
                      if (err.response && err.response.status === 409) {
                          console.log('Test user already exists, proceeding.');
                      } else {
                          console.error('Failed to register test user:', err.response?.data || err.message);
                          throw err;
                      }
                  }
              });

              afterAll(async () => {
                  try {
                     if (!authToken) {
                         const loginRes = await axios.post(`${API_BASE_URL}/login`, { username: 'ci_testuser', password: 'ci_password123' });
                         authToken = loginRes.data.token;
                     }
                     if (authToken) {
                         await axios.delete(`${API_BASE_URL}/users/ci_testuser`, { headers: { Authorization: `Bearer ${authToken}` } });
                         console.log('Test user cleaned up.');
                     }
                     // Clean up test data
                     const userKey = await redis.keys(`ci_testuser`);
                     if (userKey.length > 0) await redis.del(userKey);
                     const dataKeys = await streamRedis.keys(`*${testDetectorIdBase}*`);
                     if (dataKeys.length > 0) await streamRedis.del(dataKeys);
                      const streamKey = await streamRedis.keys('spectrogram_stream');
                      if (streamKey.length > 0) await streamRedis.del(streamKey);
                     console.log('Test data cleaned up.');
                  } catch (err) {
                      console.warn('Could not clean up test user/data:', err.response?.data || err.message);
                  }
                  await redis.quit();
                  await streamRedis.quit();
                  console.log('Redis connections closed.');
              });

              test('GET /health should return 200 OK', async () => {
                  const response = await axios.get(`${API_BASE_URL}/health`);
                  expect(response.status).toBe(200);
                  expect(response.data.status).toBe('OK');
                  expect(response.data.redis_main).toBe('OK');
                  expect(response.data.redis_stream).toBe('OK');
                  expect(response.data.postgres).toBe('OK');
              });

              test('POST /login with valid credentials should return JWT token', async () => {
                  const response = await axios.post(`${API_BASE_URL}/login`, { username: 'ci_testuser', password: 'ci_password123' });
                  expect(response.status).toBe(200);
                  expect(response.data.token).toBeDefined();
                  authToken = response.data.token;
              });

              test('POST /key-exchange requires authentication and returns key', async () => {
                  expect(authToken).toBeDefined();
                  const response = await axios.post(`${API_BASE_URL}/key-exchange`, {}, { headers: { Authorization: `Bearer ${authToken}` } });
                  expect(response.status).toBe(200);
                  expect(response.data.key).toMatch(/^[a-f0-9]{64}$/);
                  encryptionKey = response.data.key;
                  const storedKey = await redis.get(`ci_testuser`);
                  expect(storedKey).toBe(encryptionKey);
              });

              test('POST /data-ingest accepts valid batch data', async () => {
                  const testDetectorId = testDetectorIdBase + "_ingest";
                  const payload = {
                      detectorId: testDetectorId,
                      location: { lat: 1.23, lon: -4.56 },
                      // Batch of two identical raw spectra
                      spectrograms: [
                          Array(RAW_FREQUENCY_POINTS).fill(1.0),
                          Array(RAW_FREQUENCY_POINTS).fill(2.0)
                      ]
                  };
                  const headers = { 'X-API-Key': API_INGEST_KEY };

                  const response = await axios.post(`${API_BASE_URL}/data-ingest`, payload, { headers });
                  expect(response.status).toBe(202);
                  expect(response.data.messageId).toBeDefined();

                  // Check stream contains the raw data batch
                  await sleep(300); // Allow slightly more time for stream processing
                  const streamMessages = await streamRedis.xrevrange('spectrogram_stream', '+', '-', 'COUNT', 1);
                  expect(streamMessages.length).toBeGreaterThan(0);
                  const streamData = JSON.parse(streamMessages[0][1][1]); // [messageId, [key, value]]
                  expect(streamData.detectorId).toBe(testDetectorId);
                  expect(Array.isArray(streamData.spectrogram)).toBe(true);
                  expect(streamData.spectrogram.length).toBe(2); // Check batch size
                  expect(streamData.spectrogram[0].length).toBe(RAW_FREQUENCY_POINTS); // Ensure raw data is in stream
              });

              test('WebSocket receives processed data including peaks and Q-factor', async () => {
                  expect(authToken).toBeDefined();
                  expect(encryptionKey).toBeDefined();

                  const ws = new WebSocket(`${WS_URL}/?token=${authToken}`);
                  let receivedMessage = null;
                  let wsError = null;
                  let wsClosedCode = null;

                  const messagePromise = new Promise((resolve, reject) => {
                     // Increased timeout slightly for CI
                     const timeout = setTimeout(() => {
                         ws.terminate(); // Close WS on timeout
                         reject(new Error(`WebSocket message timeout after 12s (State: ${ws.readyState})`));
                     }, 12000);
                      ws.on('message', (data) => { clearTimeout(timeout); receivedMessage = data.toString('utf8'); resolve(); });
                      ws.on('error', (err) => { clearTimeout(timeout); wsError = err; reject(err); }); // Store error
                      ws.on('close', (code, reason) => { wsClosedCode = code; if (code !== 1000) reject(new Error(`WS closed unexpectedly: ${code} - ${reason}`)); });
                  });

                  // Wait for WS connection before sending data
                  await new Promise((resolve, reject) => {
                      const timeout = setTimeout(() => reject(new Error('WebSocket connection timeout')), 5000);
                      ws.on('open', () => { clearTimeout(timeout); console.log('WebSocket connected for peak test.'); resolve(); });
                      ws.on('error', (err) => { clearTimeout(timeout); reject(err); }); // Reject on immediate error too
                  });

                  // Add a small delay after 'open' before sending, maybe helps CI
                  await sleep(200);

                  // Generate test data with a clear peak
                  const rawSpectrogramWithPeak = Array(RAW_FREQUENCY_POINTS).fill(1.0);
                  const peakIndex = Math.floor(RAW_FREQUENCY_POINTS / 5); // ~11 Hz
                  const peakFreq = peakIndex * (55 / (RAW_FREQUENCY_POINTS - 1));
                  rawSpectrogramWithPeak[peakIndex - 2] = 3.0;
                  rawSpectrogramWithPeak[peakIndex - 1] = 8.0;
                  rawSpectrogramWithPeak[peakIndex] = 20.0; // Strong peak
                  rawSpectrogramWithPeak[peakIndex + 1] = 7.0;
                  rawSpectrogramWithPeak[peakIndex + 2] = 2.5;

                  const testDetectorId = testDetectorIdBase + "_ws";
                  const ingestPayload = { detectorId: testDetectorId, location: { lat: 45, lon: 45 }, spectrograms: [rawSpectrogramWithPeak] };
                  const peakKeyWs = `peaks:${testDetectorId}`;
                  await streamRedis.del(peakKeyWs); // Clean previous data

                  await axios.post(`${API_BASE_URL}/data-ingest`, ingestPayload, { headers: { 'X-API-Key': API_INGEST_KEY } });
                  console.log('Test message with peak ingested for WS test.');

                  try {
                    await messagePromise; // Wait for WS message
                  } catch(e) {
                      console.error("WS Error:", wsError);
                      console.error("WS Closed Code:", wsClosedCode);
                      throw e; // Re-throw the error to fail the test
                  }


                  expect(receivedMessage).toBeDefined();
                  expect(receivedMessage).toContain(':');

                  const [encrypted, iv] = receivedMessage.split(':');
                  const encryptedBuf = CryptoJS.enc.Base64.parse(encrypted);
                  const ivBuf = CryptoJS.enc.Base64.parse(iv);
                  const keyWordArray = CryptoJS.enc.Hex.parse(encryptionKey);

                  const decryptedBytes = CryptoJS.AES.decrypt({ ciphertext: encryptedBuf }, keyWordArray, { iv: ivBuf, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
                  const decryptedText = decryptedBytes.toString(CryptoJS.enc.Utf8);
                  const decryptedData = JSON.parse(decryptedText);

                  expect(decryptedData.detectorId).toBe(testDetectorId);
                  expect(Array.isArray(decryptedData.spectrogram)).toBe(true);
                  expect(decryptedData.spectrogram.length).toBe(1);
                  expect(decryptedData.spectrogram[0].length).toBe(EXPECTED_DOWNSAMPLED_LENGTH);
                  expect(Array.isArray(decryptedData.detectedPeaks)).toBe(true);
                  // The enhanced peak detection might find more than 1 peak due to side lobes if not perfectly tuned
                  expect(decryptedData.detectedPeaks.length).toBeGreaterThanOrEqual(1);
                  const detectedPeak = decryptedData.detectedPeaks.find(p => Math.abs(p.freq - peakFreq) < 0.5); // Find the peak near 11Hz
                  expect(detectedPeak).toBeDefined(); // Ensure the main peak was found
                  expect(detectedPeak.freq).toBeCloseTo(peakFreq, 1);
                  expect(detectedPeak.amp).toBeCloseTo(20.0, 0); // Amplitude might change slightly due to smoothing/interpolation
                  expect(detectedPeak.qFactor).toBeGreaterThan(0);
                  console.log('Received and Decrypted Peaks via WS:', decryptedData.detectedPeaks);

                  // Check if peak was stored in Redis sorted set
                  const storedPeaks = await streamRedis.zrange(peakKeyWs, 0, -1);
                  expect(storedPeaks.length).toBe(1);
                  const storedPeakDataArray = JSON.parse(storedPeaks[0]); // Server stores the array of peaks
                  expect(Array.isArray(storedPeakDataArray)).toBe(true);
                  const storedMainPeak = storedPeakDataArray.find(p => Math.abs(p.freq - peakFreq) < 0.5);
                  expect(storedMainPeak).toBeDefined();
                  expect(storedMainPeak.freq).toBeCloseTo(peakFreq, 1);


                  ws.close(1000, 'Test complete');
                  await streamRedis.del(peakKeyWs); // Clean up ws test data
              });

              test('GET /history/peaks/:hours returns historical peak data', async () => {
                  expect(authToken).toBeDefined();
                  const testDetectorId = testDetectorIdBase + "_hist";
                  const peakKeyHist = `peaks:${testDetectorId}`;
                  const nowMs = Date.now();
                  const peakSet1 = [{ freq: 7.8, amp: 15, qFactor: 4 }];
                  const peakSet2 = [{ freq: 14.1, amp: 10, qFactor: 5 }, { freq: 7.9, amp: 12, qFactor: 4.2 }];
                  await streamRedis.zadd(peakKeyHist, nowMs - 60000, JSON.stringify(peakSet1)); // 1 min ago
                  await streamRedis.zadd(peakKeyHist, nowMs, JSON.stringify(peakSet2)); // Now

                  const response = await axios.get(`${API_BASE_URL}/history/peaks/1?detectorId=${testDetectorId}`, { headers: { Authorization: `Bearer ${authToken}` } });

                  expect(response.status).toBe(200);
                  expect(Array.isArray(response.data)).toBe(true);
                  expect(response.data.length).toBe(1);
                  const detectorHistory = response.data[0];
                  expect(detectorHistory.detectorId).toBe(testDetectorId);
                  expect(Array.isArray(detectorHistory.peaks)).toBe(true);
                  expect(detectorHistory.peaks.length).toBe(2);

                  const event1 = detectorHistory.peaks[0];
                  const event2 = detectorHistory.peaks[1];
                  expect(event1.ts).toBeCloseTo(nowMs - 60000, -3);
                  expect(event1.peaks).toEqual(peakSet1);
                  expect(event2.ts).toBeCloseTo(nowMs, -3);
                  expect(event2.peaks).toEqual(peakSet2);
                  console.log('Retrieved Peak History:', JSON.stringify(detectorHistory.peaks));

                  await streamRedis.del(peakKeyHist); // Clean up test data
              });

          });
          TEST_EOF

          npx jest integration.test.js --detectOpenHandles --forceExit --verbose
        continue-on-error: false

      - name: Clean up Docker Compose resources
        if: always()
        working-directory: ./earthsync
        run: |
          echo "Cleaning up Docker resources..."
          docker compose down -v --remove-orphans --timeout 30
        continue-on-error: false
