name: Build and Test

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        continue-on-error: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
        continue-on-error: false

      - name: Install Docker Compose
        run: |
          sudo mkdir -p /usr/local/lib/docker/cli-plugins
          sudo curl -SL https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose
          sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
          docker compose version
        continue-on-error: false

      - name: Build and run services with Docker Compose
        run: |
          # Verify docker-compose.yml content
          echo "Verifying docker-compose.yml..."
          grep -A 5 "healthcheck:" "$GITHUB_WORKSPACE/earthsync/docker-compose.yml" || echo "Healthcheck section not found or malformed"
          docker compose up -d --build
        continue-on-error: false

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:3000/health; then
              echo "Server is ready!"
              break
            fi
            echo "Attempt $i/30: Server not ready yet..."
            sleep 2
          done
          if [ $i -eq 30 ]; then
            echo "Server failed to start within 60 seconds"
            docker compose logs
            exit 1
          fi
        continue-on-error: false

      - name: Set up Node.js for testing
        uses: actions/setup-node@v4
        with:
          node-version: '18'
        continue-on-error: false

      - name: Install test dependencies
        run: |
          npm install axios ws ioredis bcryptjs jsonwebtoken jest @testing-library/react @testing-library/jest-dom --save-dev
        continue-on-error: false

      - name: Run server and integration tests
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: password
        run: |
          cat << 'TEST_EOF' > test.js
          const axios = require('axios');
          const WebSocket = require('ws');
          const Redis = require('ioredis');
          const bcrypt = require('bcryptjs');
          const jwt = require('jsonwebtoken');

          const API_BASE_URL = 'http://localhost:3000';
          const WS_URL = 'ws://localhost:3000';
          const JWT_SECRET = '1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p';
          const redis = new Redis({
            host: process.env.REDIS_HOST,
            port: process.env.REDIS_PORT,
            password: process.env.REDIS_PASSWORD,
          });

          const FREQUENCY_RANGE = 5501;
          const SCHUMANN_FREQUENCIES = [7.83, 14.3, 20.8, 27.3, 33.8, 39.0, 45.0, 51.0];
          const NOISE_LEVEL = 2.0;
          const FREQUENCY_SHIFT = 0.3;
          const BASE_AMPLITUDE = 15.0;
          const AMPLITUDE_DECREASE_FACTOR = 0.8;

          function generateSpectrogram() {
            const spectrogram = new Array(FREQUENCY_RANGE).fill(0);
            SCHUMANN_FREQUENCIES.forEach((freq, index) => {
              const shift = (Math.random() - 0.5) * FREQUENCY_SHIFT;
              const indexHz = Math.floor((freq + shift) * 100);
              const amplitudeScale = BASE_AMPLITUDE * Math.pow(AMPLITUDE_DECREASE_FACTOR, index);
              for (let i = Math.max(0, indexHz - 50); i < Math.min(FREQUENCY_RANGE, indexHz + 50); i++) {
                const distance = Math.abs(i - indexHz);
                spectrogram[i] += amplitudeScale * Math.exp(-(distance * distance) / 200);
              }
            });
            for (let i = 0; i < FREQUENCY_RANGE; i++) spectrogram[i] += Math.random() * NOISE_LEVEL;
            return spectrogram;
          }

          describe('EarthSync API Tests', () => {
            let token;
            let ws;

            beforeAll(async () => {
              await redis.ping();
            });

            afterAll(async () => {
              if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
                await new Promise((resolve) => {
                  const timeout = setTimeout(() => {
                    clearTimeout(timeout);
                    resolve();
                  }, 5000);
                  ws.on('close', () => {
                    clearTimeout(timeout);
                    resolve();
                  });
                });
              }
              await redis.quit();
              if (redis.status !== 'end') {
                redis.disconnect();
              }
            }, 15000);

            test('Health endpoint', async () => {
              const response = await axios.get(`${API_BASE_URL}/health`);
              expect(response.status).toBe(200);
              expect(response.data.status).toBe('OK');
            });

            test('Register with valid data', async () => {
              try {
                await axios.delete(`${API_BASE_URL}/users/testuser`, { headers: { Authorization: `Bearer ${token}` } });
              } catch (err) {}
              const response = await axios.post(`${API_BASE_URL}/register`, { username: 'testuser', password: 'testpass123' });
              expect(response.status).toBe(201);
            });

            test('Register with existing username', async () => {
              await expect(axios.post(`${API_BASE_URL}/register`, { username: 'testuser', password: 'anotherpass' }))
                .rejects.toMatchObject({ response: { status: 400 } });
            });

            test('Login with valid credentials', async () => {
              const response = await axios.post(`${API_BASE_URL}/login`, { username: 'testuser', password: 'testpass123' });
              expect(response.status).toBe(200);
              expect(response.data.token).toBeDefined();
              token = response.data.token;
            });

            test('Login with invalid password', async () => {
              await expect(axios.post(`${API_BASE_URL}/login`, { username: 'testuser', password: 'wrongpass' }))
                .rejects.toMatchObject({ response: { status: 401 } });
            });

            test('Key exchange', async () => {
              const response = await axios.post(`${API_BASE_URL}/key-exchange`, {}, { headers: { Authorization: `Bearer ${token}` } });
              expect(response.status).toBe(200);
              expect(response.data.key).toBeDefined();
            });

            test('History with valid hours', async () => {
              await redis.del('spectrogram_history');
              for (let i = 0; i < 5; i++) {
                const spectrogram = generateSpectrogram();
                const timestamp = new Date(Date.now() - (60 - i * 10) * 60 * 1000).toISOString();
                await redis.lpush('spectrogram_history', JSON.stringify({ spectrogram, timestamp, interval: 5000 }));
              }
              const response = await axios.get(`${API_BASE_URL}/history/1`, { headers: { Authorization: `Bearer ${token}` } });
              expect(response.status).toBe(200);
              expect(Array.isArray(response.data)).toBe(true);
            });

            test('History with invalid hours', async () => {
              await expect(axios.get(`${API_BASE_URL}/history/25`, { headers: { Authorization: `Bearer ${token}` } }))
                .rejects.toMatchObject({ response: { status: 400 } });
            });

            test('Metrics endpoint', async () => {
              const response = await axios.get(`${API_BASE_URL}/metrics`);
              expect(response.status).toBe(200);
              expect(response.headers['content-type']).toContain('text/plain');
              expect(response.data).toContain('http_requests_total');
            });

            test('WebSocket connection', async () => {
              ws = new WebSocket(`${WS_URL}/?token=${token}`);
              await new Promise((resolve) => ws.on('open', resolve));
              const messagePromise = new Promise((resolve) => ws.on('message', (data) => resolve(data.toString('utf8'))));
              const spectrogram = generateSpectrogram();
              await redis.xadd('spectrogram_stream', '*', 'data', JSON.stringify({ spectrogram, timestamp: new Date().toISOString(), interval: 5000 }));
              const message = await messagePromise;
              expect(message).toContain(':');
              ws.close();
            });
          });
          TEST_EOF
          npx jest test.js --runInBand --detectOpenHandles
        continue-on-error: false

      - name: Run client-side tests
        run: |
          cd client
          npm install
          cat << 'CLIENT_TEST_EOF' > src/App.test.js
          import React from 'react';
          import { render, screen, waitFor } from '@testing-library/react';
          import '@testing-library/jest-dom';
          import App from './App';
          import axios from 'axios';

          // Mock dependencies
          jest.mock('axios');
          jest.mock('lodash.debounce', () => jest.fn((fn) => fn));
          jest.mock('lodash.throttle', () => jest.fn((fn) => fn));
          jest.mock('react-plotly.js', () => jest.fn(() => <div data-testid="plotly-mock" />)); // Direct function mock

          // Simple test to ensure Jest runs
          describe('Basic Jest Test', () => {
            test('Jest is running', () => {
              expect(true).toBe(true);
            });
          });

          // App component tests
          describe('App Component', () => {
            beforeAll(() => {
              axios.get.mockResolvedValue({ status: 200 });
              axios.post.mockResolvedValue({ status: 200, data: { key: 'mock-key' } });
            });

            beforeEach(() => {
              jest.spyOn(console, 'log').mockImplementation(() => {});
              jest.spyOn(console, 'error').mockImplementation((msg) => console.log(`Mocked error: ${msg}`));
              global.WebSocket = jest.fn(() => ({
                onopen: jest.fn(),
                onmessage: jest.fn(() => ({ spectrogram: [[1, 2, 3]] })),
                onerror: jest.fn(),
                onclose: jest.fn(),
                close: jest.fn(),
                readyState: 1,
              }));
            });

            afterEach(() => {
              localStorage.clear();
              jest.clearAllMocks();
              console.log.mockRestore();
              console.error.mockRestore();
              delete global.WebSocket;
              jest.restoreAllMocks();
            });

            test('renders login form when not authenticated', async () => {
              jest.spyOn(React, 'useState').mockImplementation((init) => [
                init === null ? { apiUrl: 'http://localhost:3000', wsUrl: 'ws://localhost:3000' } : init,
                jest.fn(),
              ]);
              jest.spyOn(React, 'useEffect').mockImplementation((fn) => fn());

              render(<App />);
              await waitFor(() => {
                expect(screen.getByRole('heading', { name: 'Login', level: 4 })).toBeInTheDocument();
                expect(screen.getByLabelText('Username')).toBeInTheDocument();
                expect(screen.getByLabelText('Password')).toBeInTheDocument();
              }, { timeout: 2000 });
            }, 5000);

            test('shows spectrogram page after login', async () => {
              jest.spyOn(React, 'useState').mockImplementation((init) => {
                if (init === false) return [true, jest.fn()]; // isAuthenticated
                if (init === null) return ['mock-token', jest.fn()]; // token
                if (Array.isArray(init)) return [init, jest.fn()]; // spectrogramData
                if (typeof init === 'string' && init.length === 0) return ['', jest.fn()]; // username, password
                if (init === true || init === false) return [init, jest.fn()]; // isRegistering, darkMode, isLoading, historicalMode, normalize, drawerOpen
                if (typeof init === 'number') return [init, jest.fn()]; // timeSteps, historicalHours
                if (init === 'Jet' || init === 'Greys') return [init, jest.fn()]; // colorScale
                return [{ apiUrl: 'http://localhost:3000', wsUrl: 'ws://localhost:3000' }, jest.fn()]; // serverUrls
              });
              jest.spyOn(React, 'useEffect').mockImplementation((fn) => {
                fn(); // Ensure useEffect runs immediately
                return () => {}; // Cleanup mock
              });

              localStorage.setItem('token', 'mock-token');
              render(<App />);
              await waitFor(() => {
                expect(screen.getByText(/Schumann Resonance 3D Surface Plot/i)).toBeInTheDocument();
              }, { timeout: 2000 });
            }, 5000);
          });
          CLIENT_TEST_EOF
          npm test -- --forceExit --verbose
        continue-on-error: false

      - name: Clean up
        if: always()
        run: |
          # Verify docker-compose.yml content before cleanup
          echo "Verifying docker-compose.yml before cleanup..."
          grep -A 5 "healthcheck:" "$GITHUB_WORKSPACE/earthsync/docker-compose.yml" || echo "Healthcheck section not found or malformed"
          docker compose down -v
        continue-on-error: false
