name: Build and Test EarthSync

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: earthsync
        continue-on-error: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
        continue-on-error: false

      - name: Install Docker Compose V2
        run: |
          DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
          mkdir -p $DOCKER_CONFIG/cli-plugins
          curl -SL https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
          chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
          docker compose version
        continue-on-error: false

      - name: Verify docker-compose.yml exists
        working-directory: ./earthsync
        run: |
          ls -l docker-compose.yml
          echo "Verifying docker-compose.yml content (healthcheck example)..."
          grep -A 5 "healthcheck:" docker-compose.yml || echo "Healthcheck section not found or malformed (may be OK)"

      - name: Build and Run Services with Docker Compose
        working-directory: ./earthsync
        run: docker compose up -d --build --remove-orphans
        continue-on-error: false

      - name: Wait for Services to be Healthy
        working-directory: ./earthsync
        run: |
          echo "Waiting for services to stabilize and become healthy..."
          sleep 15
          echo "Checking service health status..."
          MAX_RETRIES=30
          RETRY_INTERVAL=3
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking server health..."
            if curl -fsS --max-time 2 http://localhost:3000/health; then
              echo "Server is healthy!"
              break
            fi
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Server failed to become healthy within timeout."
              echo "--- Server Logs ---"
              docker compose logs server || echo "Failed to get server logs."
              echo "--- Detector1 Logs ---"
              docker compose logs detector1 || echo "Failed to get detector1 logs."
              exit 1
            fi
            sleep $RETRY_INTERVAL
          done
        continue-on-error: false

      - name: Set up Node.js for Testing
        uses: actions/setup-node@v4
        with:
          node-version: '18'
        continue-on-error: false

      - name: Install Test Dependencies
        working-directory: ./earthsync
        run: npm install --save-dev axios ws ioredis bcryptjs jsonwebtoken jest@^29 crypto-js
        continue-on-error: false

      - name: Run Integration Tests
        working-directory: ./earthsync
        env:
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          REDIS_PASSWORD: password
          API_BASE_URL: http://localhost:3000
          WS_URL: ws://localhost:3000
          JWT_SECRET: 1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p
          NODE_ENV: test
          JEST_TIMEOUT: 30000
        run: |
          cat << 'TEST_EOF' > integration.test.js
          const axios = require('axios');
          const WebSocket = require('ws');
          const Redis = require('ioredis');
          const jwt = require('jsonwebtoken');
          const CryptoJS = require('crypto-js');

          const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
          const WS_URL = process.env.WS_URL || 'ws://localhost:3000';
          const JWT_SECRET = process.env.JWT_SECRET || '1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p';
          const TEST_TIMEOUT = parseInt(process.env.JEST_TIMEOUT || '30000', 10);
          const DOWNSAMPLE_FACTOR = 5;
          const FREQUENCY_RANGE_POINTS = 5501;
          const EXPECTED_DOWNSAMPLED_LENGTH = Math.ceil(FREQUENCY_RANGE_POINTS / DOWNSAMPLE_FACTOR);

          // Main Redis client (for user keys if needed, includes prefix)
          const redis = new Redis({
              host: process.env.REDIS_HOST || 'localhost',
              port: parseInt(process.env.REDIS_PORT || '6379', 10),
              password: process.env.REDIS_PASSWORD || 'password',
              lazyConnect: true,
              keyPrefix: 'userkey:', // Match server config
              retryStrategy: times => Math.min(times * 100, 3000),
              reconnectOnError: () => true,
              maxRetriesPerRequest: 3,
              showFriendlyErrorStack: process.env.NODE_ENV !== 'production'
          });

           // Separate client for stream/history interaction (no prefix)
          const historyRedis = new Redis({
               host: process.env.REDIS_HOST || 'localhost',
               port: parseInt(process.env.REDIS_PORT || '6379', 10),
               password: process.env.REDIS_PASSWORD || 'password',
               lazyConnect: true,
               retryStrategy: times => Math.min(times * 100, 3000),
               reconnectOnError: () => true,
               maxRetriesPerRequest: 3
           });


          describe('EarthSync Integration Tests', () => {
              let authToken;
              let encryptionKey;

              jest.setTimeout(TEST_TIMEOUT);

              beforeAll(async () => {
                  try {
                      await redis.connect();
                      await historyRedis.connect();
                      await redis.ping();
                      await historyRedis.ping();
                      console.log('Redis connections successful for tests.');
                  } catch (err) {
                      console.error('Redis connection failed:', err);
                      throw new Error('Cannot connect to Redis, aborting tests.');
                  }
                  try {
                      console.log('Attempting to register test user...');
                      await axios.post(`${API_BASE_URL}/register`, { username: 'ci_testuser', password: 'ci_password123' });
                      console.log('Test user registered.');
                  } catch (err) {
                      if (err.response && err.response.status === 409) {
                          console.log('Test user already exists, proceeding.');
                      } else {
                          console.error('Failed to register test user:', err.response?.data || err.message);
                          throw err;
                      }
                  }
              });

              afterAll(async () => {
                  try {
                     if (!authToken) {
                         const loginRes = await axios.post(`${API_BASE_URL}/login`, { username: 'ci_testuser', password: 'ci_password123' });
                         authToken = loginRes.data.token;
                     }
                     if (authToken) {
                         await axios.delete(`${API_BASE_URL}/users/ci_testuser`, { headers: { Authorization: `Bearer ${authToken}` } });
                         console.log('Test user cleaned up.');
                     }
                  } catch (err) {
                      console.warn('Could not clean up test user:', err.response?.data || err.message);
                  }
                  await redis.quit();
                  await historyRedis.quit();
                  console.log('Redis connections closed.');
              });

              test('GET /health should return 200 OK', async () => {
                  const response = await axios.get(`${API_BASE_URL}/health`);
                  expect(response.status).toBe(200);
                  expect(response.data.status).toBe('OK');
                  expect(response.data.redis_main).toBe('OK');
                  expect(response.data.redis_stream).toBe('OK');
                  expect(response.data.postgres).toBe('OK');
              });

              test('POST /login with valid credentials should return JWT token', async () => {
                  const response = await axios.post(`${API_BASE_URL}/login`, { username: 'ci_testuser', password: 'ci_password123' });
                  expect(response.status).toBe(200);
                  expect(response.data.token).toBeDefined();
                  expect(typeof response.data.token).toBe('string');
                  authToken = response.data.token;
              });

              test('POST /login with invalid credentials should return 401', async () => {
                  await expect(
                      axios.post(`${API_BASE_URL}/login`, { username: 'ci_testuser', password: 'wrong_password' })
                  ).rejects.toThrow(/401/);
              });

              test('POST /key-exchange requires authentication and returns key', async () => {
                  expect(authToken).toBeDefined();
                  const response = await axios.post(`${API_BASE_URL}/key-exchange`, {}, {
                      headers: { Authorization: `Bearer ${authToken}` }
                  });
                  expect(response.status).toBe(200);
                  expect(response.data.key).toBeDefined();
                  expect(response.data.key).toMatch(/^[a-f0-9]{64}$/);
                  encryptionKey = response.data.key;

                  const storedKey = await redis.get(`ci_testuser`);
                  expect(storedKey).toBe(encryptionKey);
              });

              test('GET /history/:hours requires authentication', async () => {
                  await expect(
                      axios.get(`${API_BASE_URL}/history/1`)
                  ).rejects.toThrow(/401/);
              });

              test('GET /history/:hours returns valid data structure', async () => {
                   expect(authToken).toBeDefined();
                   const testData = {
                       spectrogram: [Array(EXPECTED_DOWNSAMPLED_LENGTH).fill(1)],
                       timestamp: new Date().toISOString(),
                       interval: 5000, detectorId: 'detector1',
                       location: { lat: 10, lon: 10 }
                   };
                   await historyRedis.lpush('spectrogram_history:detector1', JSON.stringify(testData));
                   await historyRedis.ltrim('spectrogram_history:detector1', 0, 999);

                   const response = await axios.get(`${API_BASE_URL}/history/1`, {
                       headers: { Authorization: `Bearer ${authToken}` }
                   });

                   expect(response.status).toBe(200);
                   expect(Array.isArray(response.data)).toBe(true);
                   const d1Data = response.data.find(d => d.detectorId === 'detector1');
                   expect(d1Data).toBeDefined();
                   expect(d1Data.location).toEqual({ lat: 10, lon: 10 });
                   expect(Array.isArray(d1Data.spectrogram)).toBe(true);
                   expect(d1Data.spectrogram.length).toBeGreaterThanOrEqual(EXPECTED_DOWNSAMPLED_LENGTH);
                   expect(d1Data.spectrogram[0]).toEqual(1);

                   await historyRedis.del('spectrogram_history:detector1');
              });

               test('GET /history/:hours with detectorId filter works', async () => {
                   expect(authToken).toBeDefined();
                    const ts = new Date().toISOString();
                    const loc1 = { lat: 1, lon: 1 }, loc2 = { lat: 2, lon: 2 };
                    const spec1_batch = [Array(EXPECTED_DOWNSAMPLED_LENGTH).fill(1)];
                    const spec2_batch = [Array(EXPECTED_DOWNSAMPLED_LENGTH).fill(2)];
                   await historyRedis.lpush('spectrogram_history:d_test_1', JSON.stringify({ spectrogram: spec1_batch, timestamp: ts, interval: 5000, detectorId: 'd_test_1', location: loc1 }));
                   await historyRedis.lpush('spectrogram_history:d_test_2', JSON.stringify({ spectrogram: spec2_batch, timestamp: ts, interval: 5000, detectorId: 'd_test_2', location: loc2 }));

                   const response = await axios.get(`${API_BASE_URL}/history/1?detectorId=d_test_2`, {
                       headers: { Authorization: `Bearer ${authToken}` }
                   });

                   expect(response.status).toBe(200);
                   expect(Array.isArray(response.data)).toBe(true);
                   const d2Data = response.data.find(d => d.detectorId === 'd_test_2');
                   expect(d2Data).toBeDefined();
                   expect(d2Data.spectrogram.length).toEqual(EXPECTED_DOWNSAMPLED_LENGTH);
                   expect(d2Data.spectrogram[0]).toBe(2);

                   await historyRedis.del('spectrogram_history:d_test_1', 'spectrogram_history:d_test_2');
               });

               test('WebSocket connection requires valid token and receives encrypted data', async () => {
                  expect(authToken).toBeDefined();
                  expect(encryptionKey).toBeDefined();

                  const ws = new WebSocket(`${WS_URL}/?token=${authToken}`);
                  let receivedMessage = null;
                  let connectionClosed = false;

                  const connectionPromise = new Promise((resolve, reject) => {
                      const timeout = setTimeout(() => reject(new Error('WebSocket connection timeout')), 5000);
                      ws.on('open', () => { clearTimeout(timeout); console.log('WebSocket connected for test.'); resolve(); });
                      ws.on('error', (err) => { clearTimeout(timeout); console.error('WS Test Connection Error:', err); if (!connectionClosed) reject(new Error('WebSocket connection error')); });
                      ws.on('close', (code, reason) => { clearTimeout(timeout); connectionClosed = true; if (code !== 1000) { console.log(`WS Test Closed Unexpectedly: ${code} ${reason}`); reject(new Error(`WebSocket closed unexpectedly: ${code}`)); } else { console.log('WS Test Closed Normally.'); } });
                  });

                  const messagePromise = new Promise((resolve, reject) => {
                     const timeout = setTimeout(() => reject(new Error('WebSocket message timeout')), 10000);
                      ws.on('message', (data) => { if (connectionClosed) return; clearTimeout(timeout); console.log('WebSocket message received in test.'); receivedMessage = data.toString('utf8'); resolve(); });
                  });

                  await connectionPromise;

                  const testRawSpectrogram = Array(FREQUENCY_RANGE_POINTS).fill(Math.random() * 10);
                  const messageData = {
                      spectrogram: [testRawSpectrogram],
                      timestamp: new Date().toISOString(),
                      interval: 5000,
                      detectorId: 'ws_test_detector',
                      location: { lat: 30, lon: 30 }
                  };
                  await historyRedis.xadd('spectrogram_stream', '*', 'data', JSON.stringify(messageData));
                  console.log('Test message published to Redis stream for WS test.');

                  await messagePromise;

                  expect(receivedMessage).toBeDefined();
                  expect(typeof receivedMessage).toBe('string');
                  expect(receivedMessage).toContain(':');

                  const [encrypted, iv] = receivedMessage.split(':');
                  const encryptedBuf = CryptoJS.enc.Base64.parse(encrypted);
                  const ivBuf = CryptoJS.enc.Base64.parse(iv);
                  const keyWordArray = CryptoJS.enc.Hex.parse(encryptionKey);

                  const decryptedBytes = CryptoJS.AES.decrypt({ ciphertext: encryptedBuf }, keyWordArray, { iv: ivBuf, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
                  const decryptedText = decryptedBytes.toString(CryptoJS.enc.Utf8);
                  expect(decryptedText).toBeTruthy();

                  const decryptedData = JSON.parse(decryptedText);
                  expect(decryptedData.detectorId).toBe('ws_test_detector');
                  expect(decryptedData.location).toEqual({ lat: 30, lon: 30 });
                  expect(Array.isArray(decryptedData.spectrogram[0])).toBe(true);
                  expect(decryptedData.spectrogram[0].length).toBe(EXPECTED_DOWNSAMPLED_LENGTH);

                  ws.close(1000, 'Test complete');
                  console.log('WebSocket test completed and connection closed.');
              });

          });
          TEST_EOF

          npx jest integration.test.js --detectOpenHandles --forceExit --verbose
        continue-on-error: false

      - name: Clean up Docker Compose resources
        if: always()
        working-directory: ./earthsync
        run: |
          echo "Cleaning up Docker resources..."
          docker compose down -v --remove-orphans --timeout 30
        continue-on-error: false
